# 优化方案 v0.3（中文）

目标：在保持正确性的前提下，通过软件流水与双缓冲重叠 `load_offset` 与 hash 计算，提升 `load/valu` 并行度，进一步降低 cycles。

## 关键方向（含预期收益）
- 软件流水 + 双缓冲向量寄存器：提前加载下一批次 `node_v`，与上一批次 hash 并行。（预期收益：提高 load/valu 同周期占用，减少空转周期）
- Gather 负载分摊：将 8 次 `load_offset` 分散到更多周期，避免 load 峰值阻塞。（预期收益：缓解 load 饱和带来的总周期上限）
- 常量与地址预计算：预先计算 `idx/val` 地址并复用，减少额外 ALU。（预期收益：为 VLIW 打包留出槽位，提高吞吐）
- Trace 驱动微调：使用 `trace_any.py` 对每次变更测量引擎峰值与利用率。（预期收益：定位真实瓶颈，减少无效改动）

## 实施草图
1) **双缓冲结构**
   - 两套向量寄存器：`idx_v0/val_v0/node_v0` 与 `idx_v1/val_v1/node_v1`。
   - 先为 batch0 执行 `vload idx/val + load_offset node`。
   - 进入循环：在处理 batchN 的 hash 与回写时，同时启动 batchN+1 的 node gather。

2) **流水调度**
   - 将每个 batch 拆成两个阶段：
     - Stage A：`vload idx/val` + `load_offset node`
     - Stage B：`hash + idx 更新 + vstore`
   - 交替执行 A/B，实现跨 batch 的并行。

3) **尾部处理**
   - 最后一批次完成后再执行剩余的 Stage B。
   - batch 不满 `VLEN` 走现有标量回退路径。

## 验证与度量
- 运行 `python tests/submission_tests.py` 记录 cycles。
- 运行 `python trace_any.py trace/trace.json`，观察：
  - `load` 峰值是否从 2/2 持续饱和转为与 `valu` 并行；
  - `valu` 峰值是否上升（目标接近 4-6/6）。

## 风险/缓解
- Scratch 压力上升：控制双缓冲寄存器数量，优先复用临时向量。
- 依赖错排：保持依赖保守打包，分批引入流水逻辑，逐步验证。
