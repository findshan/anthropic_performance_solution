#!/usr/bin/env python3
"""
Analyze Perfetto/Chrome trace output generated by Machine.setup_trace().

Usage:
  python trace_any.py trace/trace.json
  python trace_any.py --top 20
"""

from __future__ import annotations

import argparse
import json
import os
import re
from collections import Counter, defaultdict

try:
    from problem import SLOT_LIMITS
except Exception:
    SLOT_LIMITS = {
        "alu": 12,
        "valu": 6,
        "load": 2,
        "store": 2,
        "flow": 1,
    }


def _load_trace(path: str):
    with open(path, "r", encoding="utf-8") as f:
        text = f.read().strip()
    if not text:
        return []
    # Fix trailing commas before closing bracket if present.
    text = re.sub(r",\s*]", "]", text)
    return json.loads(text)


def _default_trace_path():
    for candidate in ("trace/trace.json", "trace.json"):
        if os.path.exists(candidate):
            return candidate
    return None


def _tid_engine_map(events):
    tid_to_engine = {}
    for e in events:
        if e.get("ph") != "M":
            continue
        if e.get("name") != "thread_name":
            continue
        args = e.get("args", {})
        label = args.get("name", "")
        if "-" not in label:
            continue
        engine = label.split("-", 1)[0]
        if engine in SLOT_LIMITS:
            tid_to_engine[e.get("tid")] = engine
    return tid_to_engine


def analyze(events, top_n: int):
    tid_to_engine = _tid_engine_map(events)
    op_events = []
    for e in events:
        if e.get("ph") != "X" or e.get("cat") != "op":
            continue
        if e.get("name") == "init":
            continue
        if not isinstance(e.get("ts"), (int, float)):
            continue
        if e.get("tid") not in tid_to_engine:
            # Skip scratch timeline events.
            continue
        op_events.append(e)

    if not op_events:
        return {
            "cycles": 0,
            "total_ops": 0,
            "engine_counts": Counter(),
            "op_counts": Counter(),
            "engine_peak": {},
        }

    max_ts = max(e["ts"] for e in op_events)
    cycles = int(max_ts) + 1

    engine_counts = Counter()
    op_counts = Counter()
    engine_ts_counts = defaultdict(lambda: defaultdict(int))

    for e in op_events:
        tid = e.get("tid")
        engine = tid_to_engine.get(tid, "unknown")
        engine_counts[engine] += 1
        op_counts[e.get("name", "unknown")] += 1
        ts = int(e["ts"])
        engine_ts_counts[engine][ts] += 1

    engine_peak = {}
    for engine, by_ts in engine_ts_counts.items():
        peak = max(by_ts.values()) if by_ts else 0
        engine_peak[engine] = peak

    return {
        "cycles": cycles,
        "total_ops": len(op_events),
        "engine_counts": engine_counts,
        "op_counts": op_counts,
        "engine_peak": engine_peak,
    }


def format_report(summary, top_n: int):
    cycles = summary["cycles"]
    total_ops = summary["total_ops"]
    engine_counts = summary["engine_counts"]
    op_counts = summary["op_counts"]
    engine_peak = summary["engine_peak"]

    lines = []
    lines.append(f"cycles: {cycles}")
    lines.append(f"total_ops: {total_ops}")

    if cycles > 0:
        lines.append("engine_utilization:")
        for engine, count in engine_counts.most_common():
            if engine not in SLOT_LIMITS or cycles == 0:
                util = "n/a"
            else:
                util = count / (cycles * SLOT_LIMITS[engine])
                util = f"{util:.2%}"
            peak = engine_peak.get(engine, 0)
            limit = SLOT_LIMITS.get(engine, 0)
            lines.append(f"  {engine}: {count} ops, util {util}, peak {peak}/{limit}")

    lines.append(f"top_ops (n={top_n}):")
    for name, count in op_counts.most_common(top_n):
        lines.append(f"  {name}: {count}")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description="Analyze trace.json output.")
    parser.add_argument("path", nargs="?", help="Path to trace.json")
    parser.add_argument("--top", type=int, default=12, help="Top N ops to show")
    args = parser.parse_args()

    path = args.path or _default_trace_path()
    if not path:
        raise SystemExit("No trace file found. Provide a path to trace.json.")

    events = _load_trace(path)
    summary = analyze(events, args.top)
    print(format_report(summary, args.top))


if __name__ == "__main__":
    main()
