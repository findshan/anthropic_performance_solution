# VLIW 调度器 v1.0 架构文档

本文档详细介绍了 v1.0 版本的 VLIW 调度器架构、依赖建模、理论性能推导及实际测试结果分析。

## 1. 核心成就

通过从贪心打包（Greedy Packing）升级为**依赖感知列表调度（Dependency-Aware List Scheduling）**，我们在保持指令集不变的情况下，通过精细的指令编排实现了巨大的性能飞跃。

| 指标 | 基线 (Baseline) | v1.0 优化版 | 提升幅度 |
| :--- | :--- | :--- | :--- |
| **总 Cycles** | ~2402 | **1771** | **~26% 减少 / ~1.35x 速度** |
| **VALU 利用率** | ~3.8 / cycle | **~5.13 / cycle** | **显著提升** |
| **Load-Only Cycles** | ~558 | **~66** | **大幅消除空转** |

---

## 2. 理论下界与实际差异

### 2.1 理论下界推导

基于 `forest_height=10`, `rounds=16`, `batch_size=256` 的工作负载，我们可以计算理论上的物理瓶颈。

核心公式：
```math
Cycles_{lower} \ge \max\left(\lceil \frac{Total_{load}}{Limit_{load}} \rceil, \lceil \frac{Total_{valu}}{Limit_{valu}} \rceil, \lceil \frac{Total_{store}}{Limit_{store}} \rceil\right)
```

假设总指令数统计如下（基于 v1.0 调度后的指令流）：
- **Total Load (L)**: ~2658 ops
- **Total VALU (V)**: ~9147 ops
- **Total Store (S)**: ~32 ops

硬件限制（每周期）：
- **Load Limit**: 2
- **VALU Limit**: 6
- **Store Limit**: 2

计算得到理论瓶颈：
- Load 瓶颈: $2658 / 2 = 1329$ cycles
- VALU 瓶颈: $9147 / 6 = 1525$ cycles
- Store 瓶颈: $32 / 2 = 16$ cycles

**理论极限值：1525 cycles** (受限于 VALU 吞吐量)

### 2.2 实际 vs 理论分析

- **实际值**: 1771 cycles
- **差距**: $1771 - 1525 = 246$ cycles

**差距来源分析**:
1.  **依赖气泡 (Dependency Bubbles)**: 数据依赖（尤其是 RAW 和 WAW）导致虽然有空闲 Slot，但无法填入指令。
2.  **启动与排空 (Fill/Drain)**: 流水线在 Segment 开始和结束时的填充与排空开销。
3.  **Slot 种类不平衡**: 某些时刻 Load 压力大但 VALU 闲置，反之亦然。

目前的 1771 cycles 已经非常接近 1525 的理论极限，说明调度器的填充效率极高。要进一步达到 1200 cycles 的终极目标，必须从**算法层面减少指令总数**（即降低 $Total_{valu}$ 和 $Total_{load}$），仅靠调度已接近天花板。

---

## 3. v1.0 调度器架构

### 3.1 依赖建模 (Dependency Modeling)

调度器在编译期构建指令依赖图（DAG），精确处理三种依赖关系，以最大化指令重叠。

```mermaid
graph TD
    A[指令 A: 写 R1]
    B[指令 B: 读 R1]
    C[指令 C: 写 R1]
    
    A -->|RAW (读后写)\n严格保序, >0 latency| B
    B -->|WAR (写后读)\n允许同周期| C
    A -->|WAW (写后写)\n严格保序| C
    
    style A fill:#f9f,stroke:#333
    style B fill:#bbf,stroke:#333
    style C fill:#bfb,stroke:#333
```

- **RAW (Read-After-Write)**: 核心依赖。`v_add v1, v2` 必须在 `v1` 被写入后才能执行。
- **WAW (Write-After-Write)**: 避免寄存器值覆盖错误。
- **WAR (Write-After-Read)**: **v1.0 的关键优化**。允许读取 `v1` 的指令和随后写入 `v1` 的指令在**同一周期**发射（读取的是旧值），这极大增加了指令并行度。

### 3.2 列表调度流程 (List Scheduling Pipeline)

v1.0 采用基于关键路径（Rank）的列表调度算法。

```mermaid
flowchart TD
    Start([开始调度 Segment]) --> BuildDAG[构建依赖图 DAG]
    BuildDAG --> CalRank[计算 Rank\n(到终点的距离)]
    CalRank --> InitReady[初始化 Ready 队列]
    
    subgraph CycleLoop [Cycle 循环]
        direction TB
        CheckResources{检查 Slot\nLoad/VALU/ALU...}
        PickInst[从 Ready 队列选取高优先指令]
        Emit[发射指令到当前 Bundle]
        UpdateReady[更新依赖 & Ready 队列]
    end
    
    InitReady --> CycleLoop
    CycleLoop -->|Segment 结束| End([结束])
```

### 3.3 优先级策略 (Priority Heuristic)

在 Ready 队列中，指令按以下元组排序：

1.  **Rank (降序)**: 优先调度关键路径上的指令，尽早解锁后续依赖。
2.  **Engine Priority (特定序)**: `Load > VALU > ALU > Store > Flow`
    - **Load 优先**: Load 通常是长延迟操作的起点，尽早发射。
    - **VALU 优先**: VALU 是系统的主要吞吐瓶颈，必须保证其高填充率。

---

## 4. 调度效果可视化

### 4.1 流水线填充对比

**基线 (Greedy)**:
由于缺乏前瞻，Load 指令往往被阻塞，导致出现大量 Load-Only 周期，VALU 单元闲置。

```mermaid
gantt
    title 基线调度 (示意)
    dateFormat S
    axisFormat %s
    
    section Cycle
    1 : active, L, L, v, v
    2 : active, L, v
    3 : active, v, v, v
    4 : crit, L, L (Load Only)
    5 : crit, L (Load Only)
    6 : active, v, v, v, v
```

**v1.0 (List Scheduling)**:
通过 Rank 预判和 WAR 优化，Load 被均匀混入 VALU 密集的区域，消除了大部分 Load-Only 气泡。

```mermaid
gantt
    title v1.0 调度 (示意)
    dateFormat S
    axisFormat %s
    
    section Cycle
    1 : active, L, L, v, v, v, v
    2 : active, L, L, v, v, v, v
    3 : active, L, v, v, v, v, v
    4 : active, L, L, v, v, v, v
    5 : active, L, v, v, v, v, v
```

## 5. 总结与展望

v1.0 架构通过引入成熟的编译器后端技术（列表调度、精确依赖图），成功挖掘了现有 VLIW 硬件的并行潜力。

- **当前状态**: 1771 Cycles (接近 1525 的理论极限)。
- **下一步方向**: 既然填充率已近极致，必须转向**减少工作量**。
    - **算法优化**: 减少不必要的 Hash 计算步骤。
    - **指令融合**: 利用更复杂的向量指令减少 VALU 操作数。
    - **内存优化**: 进一步减少冗余 Load。
