# VLIW Scheduler Architecture v1.0

The VLIW scheduler v1.0 replaces the baseline greedy bundle packing with a dependency-aware list scheduling algorithm. This upgrade significantly improves pipeline utilization and reduces load-only cycles, bringing the total cycle count from ~2400 down to **1771**.

## Core Concepts

### Dependency Modeling
The scheduler builds a Directed Acyclic Graph (DAG) for each code segment (delimited by `debug` instructions) based on three types of data dependencies:
- **RAW (Read-After-Write)**: An instruction reading a register must schedule in a cycle strictly *after* the instruction writing to that register.
- **WAW (Write-After-Write)**: An instruction writing to a register must schedule in a cycle strictly *after* a previous write to the same register.
- **WAR (Read-After-Write)**: An instruction writing to a register can be scheduled in the *same cycle* as an instruction reading the previous value of that register, but cannot be scheduled earlier.

### List Scheduling Algorithm
1. **Rank Calculation**: Each instruction is assigned a "rank" based on its distance to the end of the dependency graph (critical path length).
2. **Ready Queue**: Instructions whose dependencies are satisfied are added to a priority queue.
3. **Priority Order**: Ready instructions are sorted by:
   - Rank (Primary): Prioritize instructions on the critical path.
   - Engine Priority (Secondary): `load` > `valu` > `alu` > `store` > `flow`. This bias fills high-latency slots (loads) and high-throughput slots (valu) first.
4. **Cycle-by-Cycle Allocation**: For each cycle, the scheduler picks the highest priority instructions that fit into available VLIW slots.

## Performance Metrics

| Metric | Baseline (Greedy) | VLIW v1.0 |
| :--- | :--- | :--- |
| **Total Cycles** | ~2402 | **1771** |
| **VALU Utilization** | ~3.8 / cycle | **~5.13 / cycle** |
| **Load-only Cycles** | ~558 | **~66** |

## Implementation Details
The implementation is primarily located in `source_repo/perf_takehome.py`:
- `_schedule_segment()`: Implements the DAG construction and list scheduling logic.
- `build()`: Orchestrates the scheduling of multiple segments.

## Future Directions
To reach the theoretical goal of **1200 cycles**, further algorithmic optimizations are needed to reduce the total volume of `load` and `valu` operations, as the current utilization is already near the hardware limits for the given instruction mix.
- **Gather Load Reduction**: Pre-loading or specialized depth handling.
- **Hash Fusion**: Compressing hash chains to reduce ALU/VALU pressure.
